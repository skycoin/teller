// a local fake btcd that reports deposits to teller for testing
package main

import (
	"crypto/tls"
	"encoding/json"
	"fmt"
	"io"
	"io/ioutil"
	"net"
	"net/http"
	"os"
	"os/signal"
	"runtime"
	"strconv"
	"strings"
	"sync"
	"sync/atomic"
	"time"

	"flag"

	"errors"

	"github.com/btcsuite/btcd/btcjson"
	"github.com/btcsuite/btcd/chaincfg/chainhash"
	"github.com/btcsuite/btcd/wire"
	"github.com/btcsuite/btcutil"
	"github.com/btcsuite/websocket"
)

const (
	// websocketSendBufferSize is the number of elements the send channel
	// can queue before blocking.  Note that this only applies to requests
	// handled directly in the websocket client input handler or the async
	// handler since notifications have their own queuing mechanism
	// independent of the send channel buffer.
	websocketSendBufferSize = 50

	rpcQuirks = true

	defaultBestBlockHeight = 492478
	defaultBestBlockHash   = "00000000000000000c4ac9ec73ff6a465532c22fd9b2a7c0015a5e13128cb9ed"

	// https://blog.cloudflare.com/the-complete-guide-to-golang-net-http-timeouts/
	// The timeout configuration is necessary for public servers, or else
	// connections will be used up
	serverReadTimeout  = time.Second * 10
	serverWriteTimeout = time.Second * 60
	serverIdleTimeout  = time.Second * 120
)

// Deposit records information about a BTC deposit
type Deposit struct {
	Address string // deposit address
	Value   int64  // deposit amount. For BTC, measured in satoshis.
	Height  int64  // the block height
	Tx      string // the transaction id
	N       uint32 // the index of vout in the tx [BTC]
}

// BlockStore holds fake block data
type BlockStore struct {
	sync.RWMutex
	BestBlockHeight int32
	BlockHashes     map[int64]string
	HashBlocks      map[string]btcjson.GetBlockVerboseResult
}

var blocks = []btcjson.GetBlockVerboseResult{
	{
		Hash:   defaultBestBlockHash,
		Height: defaultBestBlockHeight,
	},
}

var defaultBlockStore *BlockStore

type commandHandler func(*rpcServer, interface{}, <-chan struct{}) (interface{}, error)

var rpcHandlers = map[string]commandHandler{
	"getblock":      handleGetBlock,
	"getbestblock":  handleGetBestBlock,
	"getblockhash":  handleGetBlockHash,
	"getblockcount": handleGetBlockCount,
	"nextdeposit":   handleNextDeposit, // for triggering a fake deposit
}

type rpcServer struct {
	started                int32
	shutdown               int32
	listeners              []net.Listener
	wg                     sync.WaitGroup
	requestProcessShutdown chan struct{}
	key                    string
	cert                   string
	address                string
	maxConcurrentReqs      int
}

// filesExists reports whether the named file or directory exists.
func fileExists(name string) bool {
	if _, err := os.Stat(name); err != nil {
		if os.IsNotExist(err) {
			return false
		}
	}
	return true
}

// genCertPair generates a key/cert pair to the paths provided.
func genCertPair(certFile, keyFile string) error {
	fmt.Printf("Generating TLS certificates...\n")

	org := "btcd autogenerated cert"
	validUntil := time.Now().Add(10 * 365 * 24 * time.Hour)
	cert, key, err := btcutil.NewTLSCertPair(org, validUntil, nil)
	if err != nil {
		return err
	}

	// Write cert and key files.
	if err = ioutil.WriteFile(certFile, cert, 0666); err != nil {
		return err
	}
	if err = ioutil.WriteFile(keyFile, key, 0600); err != nil {
		if err := os.Remove(certFile); err != nil {
			fmt.Println("Failed to remove certFile:", err)
		}
		return err
	}

	fmt.Printf("Done generating TLS certificates\n")
	return nil
}

func createNewBlock(previousHash string, previousHeight int64, deposits []Deposit) (*btcutil.Block, error) {
	newHash, err := chainhash.NewHashFromStr(previousHash)
	if err != nil {
		fmt.Printf("%v\n", err)
		return nil, err
	}

	txn := wire.NewMsgTx(1)

	var n uint32
	for _, deposit := range deposits {
		for i := n; i < deposit.N; i++ {
			txn.AddTxOut(wire.NewTxOut(int64(0), nil))
		}

		satoshi := deposit.Value

		//// Decode the provided address.
		//addr, err := btcutil.DecodeAddress(deposit.Address, &chaincfg.MainNetParams)
		//if err != nil {
		//	fmt.Printf("Invalid address or key: %v, %v\n", deposit.Address, err)
		//	return nil, err
		//}

		// Create a new script which pays to the provided address.
		pkScript := []byte(deposit.Address)

		txn.AddTxOut(wire.NewTxOut(satoshi, pkScript))

		n = deposit.N + 1
	}

	txns := []*wire.MsgTx{
		txn,
	}

	msgBlock := &wire.MsgBlock{
		Header: wire.BlockHeader{
			PrevBlock: *newHash,
			Timestamp: time.Now(),
		},
		Transactions: txns,
	}

	newBlock := btcutil.NewBlock(msgBlock)
	height := previousHeight + 1
	newBlock.SetHeight(int32(height))

	return newBlock, nil
}

func createNewEmptyBlock(previousHash string, previousHeight int64) (*btcutil.Block, error) {
	newHash, err := chainhash.NewHashFromStr(previousHash)
	if err != nil {
		fmt.Printf("%v\n", err)
		return nil, err
	}
	msgBlock := &wire.MsgBlock{
		Header: wire.BlockHeader{
			PrevBlock: *newHash,
			Timestamp: time.Now(),
		},
	}

	newBlock := btcutil.NewBlock(msgBlock)
	height := previousHeight + 1
	newBlock.SetHeight(int32(height))

	return newBlock, nil
}

func createNewBlockWithTx(previousHash string, previousHeight int64, deposits []Deposit) (*btcutil.Block, error) {
	if len(deposits) == 0 {
		return createNewEmptyBlock(previousHash, previousHeight)
	}

	return createNewBlock(previousHash, previousHeight, deposits)
}

func handleGetBestBlock(s *rpcServer, cmd interface{}, closeChan <-chan struct{}) (interface{}, error) {
	if hash, ok := defaultBlockStore.BlockHashes[int64(defaultBlockStore.BestBlockHeight)]; ok {
		result := &btcjson.GetBestBlockResult{
			Hash:   hash,
			Height: defaultBlockStore.BestBlockHeight,
		}
		return result, nil
	}
	return nil, &btcjson.RPCError{
		Code:    btcjson.ErrRPCBlockNotFound,
		Message: "Block not found",
	}
}

func handleGetBlock(s *rpcServer, cmd interface{}, closeChan <-chan struct{}) (interface{}, error) {
	c := cmd.(*btcjson.GetBlockCmd)
	if block, ok := defaultBlockStore.HashBlocks[c.Hash]; ok {
		block.NextHash = ""
		if block.Height < int64(defaultBlockStore.BestBlockHeight) {
			if hash, ok := defaultBlockStore.BlockHashes[block.Height+1]; ok {
				block.NextHash = hash
			}
		}

		return block, nil
	}

	return nil, &btcjson.RPCError{
		Code:    btcjson.ErrRPCBlockNotFound,
		Message: "Block not found",
	}
}

func handleGetBlockHash(s *rpcServer, cmd interface{}, closeChan <-chan struct{}) (interface{}, error) {
	c := cmd.(*btcjson.GetBlockHashCmd)
	if hash, ok := defaultBlockStore.BlockHashes[c.Index]; ok {
		return hash, nil
	}

	return nil, &btcjson.RPCError{
		Code:    btcjson.ErrRPCBlockNotFound,
		Message: "Block not found",
	}
}

func convertBlockToGetBlockVerboseResult(block *btcutil.Block) *btcjson.GetBlockVerboseResult {
	result := btcjson.GetBlockVerboseResult{
		Hash:   block.Hash().String(),
		Height: int64(block.Height()),
	}

	var txRawResults []btcjson.TxRawResult

	for _, tx := range block.Transactions() {
		txRawResult := btcjson.TxRawResult{
			Txid: tx.Hash().String(),
		}

		var vouts []btcjson.Vout
		for i, txOut := range tx.MsgTx().TxOut {

			pks := txOut.PkScript

			//_, addrs, _, err := txscript.ExtractPkScriptAddrs(pks, &chaincfg.MainNetParams)
			//
			//if err != nil {
			//	return nil
			//}
			//
			//addresses := make([]string, len(addrs))
			//for j := 0; j < len(addrs); j++ {
			//	addresses[j] = addrs[j].String()
			//}
			address := string(pks)

			vout := btcjson.Vout{
				Value: btcutil.Amount(txOut.Value).ToBTC(),
				N:     uint32(i),
				ScriptPubKey: btcjson.ScriptPubKeyResult{
					Addresses: []string{
						address,
					},
				},
			}

			vouts = append(vouts, vout)
		}

		txRawResult.Vout = vouts

		txRawResults = append(txRawResults, txRawResult)
	}

	result.RawTx = txRawResults
	for _, tx := range txRawResults {
		result.Tx = append(result.Tx, tx.Hash)
	}
	result.Tx = nil

	return &result
}

func handleGetBlockCount(s *rpcServer, cmd interface{}, closeChan <-chan struct{}) (interface{}, error) {
	return int64(defaultBlockStore.BestBlockHeight), nil
}

func processDeposits(deposits []Deposit) (*btcjson.GetBlockVerboseResult, error) {
	defaultBlockStore.Lock()
	defer defaultBlockStore.Unlock()

	bestHeight := int64(defaultBlockStore.BestBlockHeight)
	bestHash, ok := defaultBlockStore.BlockHashes[bestHeight]
	if !ok {
		return nil, errors.New("Block not found")
	}

	block, err := createNewBlockWithTx(bestHash, bestHeight, deposits)
	if err != nil {
		return nil, errors.New("createNewBlockWithTx failed")
	}

	// Update NextHash of previous block
	prevBlockHash := defaultBlockStore.BlockHashes[bestHeight]
	prevBlock := defaultBlockStore.HashBlocks[prevBlockHash]
	prevBlock.NextHash = block.Hash().String()
	defaultBlockStore.HashBlocks[prevBlockHash] = prevBlock

	// Add new block
	defaultBlockStore.BestBlockHeight++
	defaultBlockStore.BlockHashes[int64(defaultBlockStore.BestBlockHeight)] = block.Hash().String()
	gbvr := convertBlockToGetBlockVerboseResult(block)
	defaultBlockStore.HashBlocks[block.Hash().String()] = *gbvr

	return gbvr, nil
}

func handleNextDeposit(s *rpcServer, cmd interface{}, closeChan <-chan struct{}) (interface{}, error) {
	var deposits []Deposit
	if cmd != nil {
		deposits = cmd.([]Deposit)
		fmt.Printf("Got %v\n", deposits)
	}

	newBlock, err := processDeposits(deposits)

	if err != nil {
		fmt.Printf("processDeposits %v\n", err)
		return nil, &btcjson.RPCError{
			Code:    btcjson.ErrRPCBlockNotFound,
			Message: "Block not found",
		}
	}

	return newBlock, nil
}

func (s *rpcServer) WebsocketHandler(conn *websocket.Conn, remoteAddr string) {
	// Clear the read deadline that was set before the websocket hijacked
	// the connection.
	if err := conn.SetReadDeadline(timeZeroVal); err != nil {
		fmt.Println("conn.SetReadDeadline failed:", err)
	}

	// Create a new websocket client to handle the new websocket connection
	// and wait for it to shutdown.  Once it has shutdown (and hence
	// disconnected), remove it and any notifications it registered for.
	client, err := newWebsocketClient(s, conn, remoteAddr)
	if err != nil {
		fmt.Printf("Failed to serve client %s: %v\n", remoteAddr, err)
		if err := conn.Close(); err != nil {
			fmt.Println("Failed to close connection:", err)
		}
		return
	}
	client.Start()
	client.WaitForShutdown()
	fmt.Printf("Disconnected websocket client %s\n", remoteAddr)
}

//func (s *rpcServer) checkAuth(r *http.Request, require bool) (bool, bool, error) {
//	return true, false, nil
//}

// parseListeners determines whether each listen address is IPv4 and IPv6 and
// returns a slice of appropriate net.Addrs to listen on with TCP. It also
// properly detects addresses which apply to "all interfaces" and adds the
// address as both IPv4 and IPv6.
func parseListeners(addrs []string) ([]net.Addr, error) {
	netAddrs := make([]net.Addr, 0, len(addrs)*2)
	for _, addr := range addrs {
		host, _, err := net.SplitHostPort(addr)
		if err != nil {
			// Shouldn't happen due to already being normalized.
			return nil, err
		}

		// Empty host or host of * on plan9 is both IPv4 and IPv6.
		if host == "" || (host == "*" && runtime.GOOS == "plan9") {
			netAddrs = append(netAddrs, simpleAddr{net: "tcp4", addr: addr})
			netAddrs = append(netAddrs, simpleAddr{net: "tcp6", addr: addr})
			continue
		}

		// Strip IPv6 zone id if present since net.ParseIP does not
		// handle it.
		zoneIndex := strings.LastIndex(host, "%")
		if zoneIndex > 0 {
			host = host[:zoneIndex]
		}

		// Parse the IP.
		ip := net.ParseIP(host)
		if ip == nil {
			return nil, fmt.Errorf("'%s' is not a valid IP address", host)
		}

		// To4 returns nil when the IP is not an IPv4 address, so use
		// this determine the address type.
		if ip.To4() == nil {
			netAddrs = append(netAddrs, simpleAddr{net: "tcp6", addr: addr})
		} else {
			netAddrs = append(netAddrs, simpleAddr{net: "tcp4", addr: addr})
		}
	}
	return netAddrs, nil
}

func setupRPCListeners(key string, cert string, address string) ([]net.Listener, error) {
	// Generate the TLS cert and key file if both don't already
	// exist.
	if !fileExists(key) && !fileExists(cert) {
		err := genCertPair(cert, key)
		if err != nil {
			return nil, err
		}
	}
	keypair, err := tls.LoadX509KeyPair(cert, key)
	if err != nil {
		return nil, err
	}

	tlsConfig := tls.Config{
		Certificates: []tls.Certificate{keypair},
		MinVersion:   tls.VersionTLS12,
	}

	// Change the standard net.Listen function to the tls one.
	listenFunc := func(net string, laddr string) (net.Listener, error) {
		return tls.Listen(net, laddr, &tlsConfig)
	}

	netAddrs, err := parseListeners([]string{address})
	if err != nil {
		return nil, err
	}

	listeners := make([]net.Listener, 0, len(netAddrs))
	for _, addr := range netAddrs {
		listener, err := listenFunc(addr.Network(), addr.String())
		if err != nil {
			fmt.Printf("Can't listen on %s: %v\n", addr, err)
			continue
		}
		listeners = append(listeners, listener)
	}

	return listeners, nil
}

// parsedRPCCmd represents a JSON-RPC request object that has been parsed into
// a known concrete command along with any error that might have happened while
// parsing it.
type parsedRPCCmd struct {
	id     interface{}
	method string
	cmd    interface{}
	err    *btcjson.RPCError
}

// parseCmd parses a JSON-RPC request object into known concrete command.  The
// err field of the returned parsedRPCCmd struct will contain an RPC error that
// is suitable for use in replies if the command is invalid in some way such as
// an unregistered command or invalid parameters.
func parseCmd(request *btcjson.Request) *parsedRPCCmd {
	var parsedCmd parsedRPCCmd
	parsedCmd.id = request.ID
	parsedCmd.method = request.Method

	cmd, err := btcjson.UnmarshalCmd(request)

	// Handle new commands except btcd cmds
	if request.Method == "nextdeposit" {
		if len(request.Params) == 1 {
			var deposit []Deposit
			err := json.Unmarshal(request.Params[0], &deposit)
			if err != nil {
				parsedCmd.err = btcjson.ErrRPCMethodNotFound
				return &parsedCmd
			}
			fmt.Printf("%v\n", deposit)
			parsedCmd.cmd = deposit
		}
		return &parsedCmd
	}

	if err != nil {
		// When the error is because the method is not registered,
		// produce a method not found RPC error.
		if jerr, ok := err.(btcjson.Error); ok &&
			jerr.ErrorCode == btcjson.ErrUnregisteredMethod {

			parsedCmd.err = btcjson.ErrRPCMethodNotFound
			return &parsedCmd
		}

		// Otherwise, some type of invalid parameters is the
		// cause, so produce the equivalent RPC error.
		parsedCmd.err = btcjson.NewRPCError(
			btcjson.ErrRPCInvalidParams.Code, err.Error())
		return &parsedCmd
	}

	parsedCmd.cmd = cmd
	return &parsedCmd
}

// standardCmdResult checks that a parsed command is a standard Bitcoin JSON-RPC
// command and runs the appropriate handler to reply to the command.  Any
// commands which are not recognized or not implemented will return an error
// suitable for use in replies.
func (s *rpcServer) standardCmdResult(cmd *parsedRPCCmd, closeChan <-chan struct{}) (interface{}, error) {
	handler, ok := rpcHandlers[cmd.method]
	if ok {
		return handler(s, cmd.cmd, closeChan)
	}
	return nil, btcjson.ErrRPCMethodNotFound
}

// createMarshalledReply returns a new marshalled JSON-RPC response given the
// passed parameters.  It will automatically convert errors that are not of
// the type *btcjson.RPCError to the appropriate type as needed.
func createMarshalledReply(id, result interface{}, replyErr error) ([]byte, error) {
	var jsonErr *btcjson.RPCError
	if replyErr != nil {
		if jErr, ok := replyErr.(*btcjson.RPCError); ok {
			jsonErr = jErr
		} else {
			jsonErr = btcjson.NewRPCError(btcjson.ErrRPCInternal.Code, replyErr.Error())
		}
	}

	return btcjson.MarshalResponse(id, result, jsonErr)
}

// httpStatusLine returns a response Status-Line (RFC 2616 Section 6.1)
// for the given request and response status code.  This function was lifted and
// adapted from the standard library HTTP server code since it's not exported.
func (s *rpcServer) httpStatusLine(req *http.Request) string {
	code := http.StatusOK
	proto11 := req.ProtoAtLeast(1, 1)

	proto := "HTTP/1.0"
	if proto11 {
		proto = "HTTP/1.1"
	}
	codeStr := strconv.Itoa(code)
	text := http.StatusText(code)
	if text != "" {
		return proto + " " + codeStr + " " + text + "\r\n"
	}

	text = "status code " + codeStr
	return proto + " " + codeStr + " " + text + "\r\n"
}

// writeHTTPResponseHeaders writes the necessary response headers prior to
// writing an HTTP body given a request to use for protocol negotiation, headers
// to write, and a writer.
func (s *rpcServer) writeHTTPResponseHeaders(req *http.Request, headers http.Header, w io.Writer) error {
	_, err := io.WriteString(w, s.httpStatusLine(req))
	if err != nil {
		return err
	}

	err = headers.Write(w)
	if err != nil {
		return err
	}

	_, err = io.WriteString(w, "\r\n")
	return err
}

// jsonRPCRead handles reading and responding to RPC messages.
func (s *rpcServer) jsonRPCRead(w http.ResponseWriter, r *http.Request) {
	if atomic.LoadInt32(&s.shutdown) != 0 {
		return
	}

	// Read and close the JSON-RPC request body from the caller.
	body, err := ioutil.ReadAll(r.Body)
	if err := r.Body.Close(); err != nil {
		fmt.Println("Failed to close response body:", err)
	}

	if err != nil {
		errCode := http.StatusBadRequest
		http.Error(w, fmt.Sprintf("%d error reading JSON message: %v",
			errCode, err), errCode)
		return
	}

	// Unfortunately, the http server doesn't provide the ability to
	// change the read deadline for the new connection and having one breaks
	// long polling.  However, not having a read deadline on the initial
	// connection would mean clients can connect and idle forever.  Thus,
	// hijack the connecton from the HTTP server, clear the read deadline,
	// and handle writing the response manually.
	hj, ok := w.(http.Hijacker)
	if !ok {
		errMsg := "webserver doesn't support hijacking"
		fmt.Print(errMsg)
		errCode := http.StatusInternalServerError
		http.Error(w, strconv.Itoa(errCode)+" "+errMsg, errCode)
		return
	}
	conn, buf, err := hj.Hijack()
	if err != nil {
		fmt.Printf("Failed to hijack HTTP connection: %v", err)
		errCode := http.StatusInternalServerError
		http.Error(w, strconv.Itoa(errCode)+" "+err.Error(), errCode)
		return
	}
	defer func() {
		if err := conn.Close(); err != nil {
			fmt.Println("conn.Close failed:", err)
		}
	}()
	defer func() {
		if err := buf.Flush(); err != nil {
			fmt.Println("buf.Flush failed:", err)
		}
	}()
	if err := conn.SetReadDeadline(timeZeroVal); err != nil {
		fmt.Println("conn.SetReadDeadline failed:", err)
	}

	// Attempt to parse the raw body into a JSON-RPC request.
	var responseID interface{}
	var jsonErr error
	var result interface{}
	var request btcjson.Request
	if err := json.Unmarshal(body, &request); err != nil {
		jsonErr = &btcjson.RPCError{
			Code:    btcjson.ErrRPCParse.Code,
			Message: "Failed to parse request: " + err.Error(),
		}
	}
	if jsonErr == nil {
		// The JSON-RPC 1.0 spec defines that notifications must have their "id"
		// set to null and states that notifications do not have a response.
		//
		// A JSON-RPC 2.0 notification is a request with "json-rpc":"2.0", and
		// without an "id" member. The specification states that notifications
		// must not be responded to. JSON-RPC 2.0 permits the null value as a
		// valid request id, therefore such requests are not notifications.
		//
		// Bitcoin Core serves requests with "id":null or even an absent "id",
		// and responds to such requests with "id":null in the response.
		//
		// Btcd does not respond to any request without and "id" or "id":null,
		// regardless the indicated JSON-RPC protocol version unless RPC quirks
		// are enabled. With RPC quirks enabled, such requests will be responded
		// to if the reqeust does not indicate JSON-RPC version.
		//
		// RPC quirks can be enabled by the user to avoid compatibility issues
		// with software relying on Core's behavior.
		if request.ID == nil && !(rpcQuirks && request.Jsonrpc == "") {
			return
		}

		// The parse was at least successful enough to have an ID so
		// set it for the response.
		responseID = request.ID

		// Setup a close notifier.  Since the connection is hijacked,
		// the CloseNotifer on the ResponseWriter is not available.
		closeChan := make(chan struct{}, 1)
		go func() {
			_, err := conn.Read(make([]byte, 1))
			if err != nil {
				close(closeChan)
			}
		}()

		if jsonErr == nil {
			// Attempt to parse the JSON-RPC request into a known concrete
			// command.
			parsedCmd := parseCmd(&request)

			if parsedCmd.err != nil {
				jsonErr = parsedCmd.err
			} else {
				result, jsonErr = s.standardCmdResult(parsedCmd, closeChan)
			}
		}
	}

	// Marshal the response.
	msg, err := createMarshalledReply(responseID, result, jsonErr)
	if err != nil {
		fmt.Printf("Failed to marshal reply: %v\n", err)
		return
	}

	// Write the response.
	err = s.writeHTTPResponseHeaders(r, w.Header(), buf)
	if err != nil {
		fmt.Printf("%v\n", err)
		return
	}
	if _, err := buf.Write(msg); err != nil {
		fmt.Printf("Failed to write marshalled reply: %v\n", err)
	}

	// Terminate with newline to maintain compatibility with Bitcoin Core.
	if err := buf.WriteByte('\n'); err != nil {
		fmt.Printf("Failed to append terminating newline to reply: %v\n", err)
	}
}

func (s *rpcServer) Start() {
	if atomic.AddInt32(&s.started, 1) != 1 {
		return
	}

	rpcServeMux := http.NewServeMux()
	httpServer := &http.Server{
		Handler: rpcServeMux,
	}

	rpcServeMux.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set("Connection", "close")
		w.Header().Set("Content-Type", "application/json")
		r.Close = true

		// Read and respond to the request.
		s.jsonRPCRead(w, r)
	})

	rpcServeMux.HandleFunc("/ws", func(w http.ResponseWriter, r *http.Request) {
		// Attempt to upgrade the connection to a websocket connection
		// using the default size for read/write buffers.
		ws, err := websocket.Upgrade(w, r, nil, 0, 0)
		if err != nil {
			if _, ok := err.(websocket.HandshakeError); !ok {
				fmt.Printf("Unexpected websocket error: %v\n", err)
			}
			http.Error(w, "400 Bad Request.", http.StatusBadRequest)
			return
		}
		s.WebsocketHandler(ws, r.RemoteAddr)
	})

	listeners, err := setupRPCListeners(s.key, s.cert, s.address)
	if err != nil {
		fmt.Printf("Unexpected setupRPCListeners error: %v\n", err)
		return
	}

	s.listeners = listeners

	for _, listener := range listeners {
		s.wg.Add(1)
		go func(listener net.Listener) {
			defer s.wg.Done()
			fmt.Printf("RPC server listening on %s\n", listener.Addr())
			if err := httpServer.Serve(listener); err != nil {
				fmt.Println("httpServer.Serve failed:", err)
				return
			}
			fmt.Printf("RPC listener done for %s\n", listener.Addr())
		}(listener)
	}
}

func (s *rpcServer) Stop() error {
	if atomic.AddInt32(&s.shutdown, 1) != 1 {
		fmt.Printf("RPC server is already in the process of shutting down\n")
		return nil
	}

	for _, listener := range s.listeners {
		err := listener.Close()
		if err != nil {
			fmt.Printf("Problem shutting down rpc: %v\n", err)
			return err
		}
	}
	s.wg.Wait()
	fmt.Printf("RPC server shutdown complete\n")

	return nil
}

// RequestedProcessShutdown returns a channel that is sent to when an authorized
// RPC client requests the process to shutdown.  If the request can not be read
// immediately, it is dropped.
func (s *rpcServer) RequestedProcessShutdown() <-chan struct{} {
	return s.requestProcessShutdown
}

// shutdownRequestChannel is used to initiate shutdown from one of the
// subsystems using the same code paths as when an interrupt signal is received.
var shutdownRequestChannel = make(chan struct{})

// interruptSignals defines the default signals to catch in order to do a proper
// shutdown.  This may be modified during init depending on the platform.
var interruptSignals = []os.Signal{os.Interrupt}

// interruptListener listens for OS Signals such as SIGINT (Ctrl+C) and shutdown
// requests from shutdownRequestChannel.  It returns a channel that is closed
// when either signal is received.
func interruptListener() <-chan struct{} {
	c := make(chan struct{})
	go func() {
		interruptChannel := make(chan os.Signal, 1)
		signal.Notify(interruptChannel, interruptSignals...)

		// Listen for initial shutdown signal and close the returned
		// channel to notify the caller.
		select {
		case sig := <-interruptChannel:
			fmt.Printf("Received signal (%s).  Shutting down...\n",
				sig)

		case <-shutdownRequestChannel:
			fmt.Printf("Shutdown requested.  Shutting down...\n")
		}
		close(c)

		// Listen for repeated signals and display a message so the user
		// knows the shutdown is in progress and the process is not
		// hung.
		for {
			select {
			case sig := <-interruptChannel:
				fmt.Printf("Received signal (%s).  Already "+
					"shutting down...", sig)

			case <-shutdownRequestChannel:
				fmt.Printf("Shutdown requested.  Already " +
					"shutting down...")
			}
		}
	}()

	return c
}

// onionAddr implements the net.Addr interface with two struct fields
type simpleAddr struct {
	net, addr string
}

// String returns the address.
//
// This is part of the net.Addr interface.
func (a simpleAddr) String() string {
	return a.addr
}

// Network returns the network.
//
// This is part of the net.Addr interface.
func (a simpleAddr) Network() string {
	return a.net
}

// timeZeroVal is simply the zero value for a time.Time and is used to avoid
// creating multiple instances.
var timeZeroVal time.Time

// wsResponse houses a message to send to a connected websocket client as
// well as a channel to reply on when the message is sent.
type wsResponse struct {
	msg      []byte
	doneChan chan bool
}

type semaphore chan struct{}

func makeSemaphore(n int) semaphore {
	return make(chan struct{}, n)
}

func (s semaphore) acquire() { s <- struct{}{} }
func (s semaphore) release() { <-s }

// wsClient provides an abstraction for handling a websocket client.
type wsClient struct {
	sync.Mutex

	// server is the RPC server that is servicing the client.
	server *rpcServer

	// conn is the underlying websocket connection.
	conn *websocket.Conn

	// disconnected indicated whether or not the websocket client is
	// disconnected.
	disconnected bool

	// addr is the remote address of the client.
	addr string

	// sessionID is a random ID generated for each client when connected.
	// These IDs may be queried by a client using the session RPC.  A change
	// to the session ID indicates that the client reconnected.
	sessionID uint64

	// verboseTxUpdates specifies whether a client has requested verbose
	// information about all new transactions.
	// verboseTxUpdates bool

	// addrRequests is a set of addresses the caller has requested to be
	// notified about.  It is maintained here so all requests can be removed
	// when a wallet disconnects.  Owned by the notification manager.
	addrRequests map[string]struct{}

	// spentRequests is a set of unspent Outpoints a wallet has requested
	// notifications for when they are spent by a processed transaction.
	// Owned by the notification manager.
	spentRequests map[wire.OutPoint]struct{}

	// Networking infrastructure.
	serviceRequestSem semaphore
	// ntfnChan          chan []byte
	sendChan chan wsResponse
	quit     chan struct{}
	wg       sync.WaitGroup
}

// newWebsocketClient returns a new websocket client given the notification
// manager, websocket connection, remote address, and whether or not the client
// has already been authenticated (via HTTP Basic access authentication).  The
// returned client is ready to start.  Once started, the client will process
// incoming and outgoing messages in separate goroutines complete with queuing
// and asynchrous handling for long-running operations.
func newWebsocketClient(server *rpcServer, conn *websocket.Conn,
	remoteAddr string) (*wsClient, error) {

	sessionID, err := wire.RandomUint64()
	if err != nil {
		return nil, err
	}

	client := &wsClient{
		conn:              conn,
		addr:              remoteAddr,
		sessionID:         sessionID,
		server:            server,
		addrRequests:      make(map[string]struct{}),
		spentRequests:     make(map[wire.OutPoint]struct{}),
		serviceRequestSem: makeSemaphore(server.maxConcurrentReqs),
		sendChan:          make(chan wsResponse, websocketSendBufferSize),
		quit:              make(chan struct{}),
	}
	return client, nil
}

// Start begins processing input and output messages.
func (c *wsClient) Start() {
	fmt.Printf("Starting websocket client %s\n", c.addr)

	// Start processing input and output.
	c.wg.Add(2)
	go c.inHandler()
	go c.outHandler()
}

// inHandler handles all incoming messages for the websocket connection.  It
// must be run as a goroutine.
func (c *wsClient) inHandler() {
out:
	for {
		// Break out of the loop once the quit channel has been closed.
		// Use a non-blocking select here so we fall through otherwise.
		select {
		case <-c.quit:
			break out
		default:
		}

		_, msg, err := c.conn.ReadMessage()
		if err != nil {
			// Log the error if it's not due to disconnecting.
			if err != io.EOF {
				fmt.Printf("Websocket receive error from %s: %v\n", c.addr, err)
			}
			break out
		}

		var request btcjson.Request
		err = json.Unmarshal(msg, &request)
		if err != nil {
			jsonErr := &btcjson.RPCError{
				Code:    btcjson.ErrRPCParse.Code,
				Message: "Failed to parse request: " + err.Error(),
			}
			reply, err := createMarshalledReply(nil, nil, jsonErr)
			if err != nil {
				fmt.Printf("Failed to marshal parse failure reply: %v\n", err)
				continue
			}
			c.SendMessage(reply, nil)
			continue
		}

		cmd := parseCmd(&request)
		if cmd.err != nil {
			reply, err := createMarshalledReply(cmd.id, nil, cmd.err)
			if err != nil {
				fmt.Printf("Failed to marshal parse failure reply: %v\n", err)
				continue
			}
			c.SendMessage(reply, nil)
			continue
		}
		fmt.Printf("Received command <%s> from %s\n", cmd.method, c.addr)

		// Asynchronously handle the request.  A semaphore is used to
		// limit the number of concurrent requests currently being
		// serviced.  If the semaphore can not be acquired, simply wait
		// until a request finished before reading the next RPC request
		// from the websocket client.
		//
		// This could be a little fancier by timing out and erroring
		// when it takes too long to service the request, but if that is
		// done, the read of the next request should not be blocked by
		// this semaphore, otherwise the next request will be read and
		// will probably sit here for another few seconds before timing
		// out as well.  This will cause the total timeout duration for
		// later requests to be much longer than the check here would
		// imply.
		//
		// If a timeout is added, the semaphore acquiring should be
		// moved inside of the new goroutine with a select statement
		// that also reads a time.After channel.  This will unblock the
		// read of the next request from the websocket client and allow
		// many requests to be waited on concurrently.
		c.serviceRequestSem.acquire()
		go func() {
			c.serviceRequest(cmd)
			c.serviceRequestSem.release()
		}()
	}

	// Ensure the connection is closed.
	c.Disconnect()
	c.wg.Done()
	fmt.Printf("Websocket client input handler done for %s\n", c.addr)
}

// outHandler handles all outgoing messages for the websocket connection.  It
// must be run as a goroutine.  It uses a buffered channel to serialize output
// messages while allowing the sender to continue running asynchronously.  It
// must be run as a goroutine.
func (c *wsClient) outHandler() {
out:
	for {
		// Send any messages ready for send until the quit channel is
		// closed.
		select {
		case r := <-c.sendChan:
			err := c.conn.WriteMessage(websocket.TextMessage, r.msg)
			if err != nil {
				c.Disconnect()
				break out
			}
			if r.doneChan != nil {
				r.doneChan <- true
			}

		case <-c.quit:
			break out
		}
	}

	// Drain any wait channels before exiting so nothing is left waiting
	// around to send.
cleanup:
	for {
		select {
		case r := <-c.sendChan:
			if r.doneChan != nil {
				r.doneChan <- false
			}
		default:
			break cleanup
		}
	}
	c.wg.Done()
	fmt.Printf("Websocket client output handler done for %s\n", c.addr)
}

// wsCommandHandler describes a callback function used to handle a specific
// command.
type wsCommandHandler func(*wsClient, interface{}) (interface{}, error)

// wsHandlers maps RPC command strings to appropriate websocket handler
// functions.  This is set by init because help references wsHandlers and thus
// causes a dependency loop.
var wsHandlers map[string]wsCommandHandler

// var wsHandlersBeforeInit = map[string]wsCommandHandler{}

// serviceRequest services a parsed RPC request by looking up and executing the
// appropriate RPC handler.  The response is marshalled and sent to the
// websocket client.
func (c *wsClient) serviceRequest(r *parsedRPCCmd) {
	var (
		result interface{}
		err    error
	)

	// Lookup the websocket extension for the command and if it doesn't
	// exist fallback to handling the command as a standard command.
	wsHandler, ok := wsHandlers[r.method]
	if ok {
		result, err = wsHandler(c, r.cmd)
	} else {
		result, err = c.server.standardCmdResult(r, nil)
	}
	reply, err := createMarshalledReply(r.id, result, err)
	if err != nil {
		fmt.Printf("Failed to marshal reply for <%s> command: %v\n", r.method, err)
		return
	}
	c.SendMessage(reply, nil)
}

// SendMessage sends the passed json to the websocket client.  It is backed
// by a buffered channel, so it will not block until the send channel is full.
// Note however that QueueNotification must be used for sending async
// notifications instead of the this function.  This approach allows a limit to
// the number of outstanding requests a client can make without preventing or
// blocking on async notifications.
func (c *wsClient) SendMessage(marshalledJSON []byte, doneChan chan bool) {
	// Don't send the message if disconnected.
	if c.Disconnected() {
		if doneChan != nil {
			doneChan <- false
		}
		return
	}

	c.sendChan <- wsResponse{msg: marshalledJSON, doneChan: doneChan}
}

// Disconnected returns whether or not the websocket client is disconnected.
func (c *wsClient) Disconnected() bool {
	c.Lock()
	isDisconnected := c.disconnected
	c.Unlock()

	return isDisconnected
}

// Disconnect disconnects the websocket client.
func (c *wsClient) Disconnect() {
	c.Lock()
	defer c.Unlock()

	// Nothing to do if already disconnected.
	if c.disconnected {
		return
	}

	fmt.Printf("Disconnecting websocket client %s\n", c.addr)
	close(c.quit)
	if err := c.conn.Close(); err != nil {
		fmt.Println("Failed to close connection:", err)
	}
	c.disconnected = true
}

// WaitForShutdown blocks until the websocket client goroutines are stopped
// and the connection is closed.
func (c *wsClient) WaitForShutdown() {
	c.wg.Wait()
}

type httpAPIServer struct {
	address string
	listen  *http.Server
	quit    chan struct{}
}

func newHTTPAPIServer(address string) *httpAPIServer {
	return &httpAPIServer{
		address: address,
		quit:    make(chan struct{}),
	}
}

// JSONResponse marshal data into json and write response
func JSONResponse(w http.ResponseWriter, data interface{}) error {
	w.Header().Set("Content-Type", "application/json")
	d, err := json.MarshalIndent(data, "", "    ")
	if err != nil {
		return err
	}

	_, err = w.Write(d)
	return err
}

// httpHandleNextDeposit accept deposits and create a new block, returns the block height.
// Method: POST
// URI: /api/nextdeposit
// The request body is an array of deposits, for example:
//  [{
//     "Address": "1FeDtFhARLxjKUPPkQqEBL78tisenc9znS",
//     "Value":   10000,
//     "N":       4
//  }]
func httpHandleNextDeposit(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Connection", "close")
	r.Close = true

	if r.Method != http.MethodPost {
		errCode := http.StatusMethodNotAllowed
		http.Error(w, fmt.Sprintf("Accepts POST requests only"), errCode)
	}

	// Read and respond to the request.
	decoder := json.NewDecoder(r.Body)
	var deposits []Deposit
	err := decoder.Decode(&deposits)
	defer func() {
		if err := r.Body.Close(); err != nil {
			fmt.Println("Failed to close response body:", err)
		}
	}()

	if err != nil {
		errCode := http.StatusBadRequest
		http.Error(w, fmt.Sprintf("%d error reading JSON message: %v", errCode, err), errCode)
		return
	}

	newBlock, err := processDeposits(deposits)
	if err != nil {
		errCode := http.StatusBadRequest
		http.Error(w, fmt.Sprintf("%d error processing data: %v", errCode, err), errCode)
		return
	}

	if err := JSONResponse(w, newBlock); err != nil {
		errCode := http.StatusBadRequest
		http.Error(w, fmt.Sprintf("%d error responding: %v", errCode, err), errCode)
		return
	}
}

func (server *httpAPIServer) start() error {
	mux := http.NewServeMux()
	mux.HandleFunc("/api/nextdeposit", httpHandleNextDeposit)

	server.listen = &http.Server{
		Addr:         server.address,
		Handler:      mux,
		ReadTimeout:  serverReadTimeout,
		WriteTimeout: serverWriteTimeout,
		IdleTimeout:  serverIdleTimeout,
	}

	if err := server.listen.ListenAndServe(); err != nil {
		select {
		case <-server.quit:
			return nil
		default:
			return err
		}
	}
	return nil
}

func (server *httpAPIServer) stop() {
	close(server.quit)
	if server.listen != nil {
		if err := server.listen.Close(); err != nil {
			fmt.Println("http api server shutdown failed")
		}
	}
}

func run() error {
	//flags
	keyFile := flag.String("key", "rpc.key", "btcd rpc key")
	certFile := flag.String("cert", "rpc.cert", "btcd rpc cert")
	address := flag.String("address", "127.0.0.1:8334", "btcd listening address")
	httpAPIAddress := flag.String("api", "127.0.0.1:8834", "http api listening address")

	flag.Parse()

	// Get a channel that will be closed when a shutdown signal has been
	// triggered either from an OS signal such as SIGINT (Ctrl+C) or from
	// another subsystem such as the RPC server.
	interruptedChan := interruptListener()

	server := rpcServer{
		requestProcessShutdown: make(chan struct{}),
		key:               *keyFile,
		cert:              *certFile,
		address:           *address,
		maxConcurrentReqs: 10,
	}

	apiServer := newHTTPAPIServer(*httpAPIAddress)

	defer func() {
		apiServer.stop()
		if err := server.Stop(); err != nil {
			fmt.Println("server.Stop failed:", err)
		}
		fmt.Printf("Shutdown complete")
	}()

	// Signal process shutdown when the RPC server requests it.
	go func() {
		<-server.RequestedProcessShutdown()
		shutdownRequestChannel <- struct{}{}
	}()

	server.Start()

	go func() {
		fmt.Printf("HTTP API server listening on http://%s\n", *httpAPIAddress)
		err := apiServer.start()
		if err != nil {
			fmt.Printf("HTTP API server failed to start")
		}
	}()

	// Wait until the interrupt signal is received from an OS signal or
	// shutdown is requested through one of the subsystems such as the RPC
	// server.
	<-interruptedChan
	return nil
}

func main() {
	if err := run(); err != nil {
		os.Exit(1)
	}
}

func init() {
	defaultBlockStore = &BlockStore{
		BestBlockHeight: defaultBestBlockHeight,
		BlockHashes:     make(map[int64]string),
		HashBlocks:      make(map[string]btcjson.GetBlockVerboseResult),
	}
	for _, b := range blocks {
		defaultBlockStore.BlockHashes[b.Height] = b.Hash
		defaultBlockStore.HashBlocks[b.Hash] = b
	}
}
